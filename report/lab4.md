# lab4



## 编程内容

实现了 `mmap` 和 `mumap` 两种系统调用，需要实现相应的`insert_framed_area` 和 `remove_framed_area` 建立和删除虚存映射

在框架基础上改进错误检查，修改某些函数的返回值为 `Result<>` ，出错时不直接 `panic`，而是返回 `Err`

修改 `sys_get_time`，实现将虚地址转化为实地址的函数并将时间写入



## 问答作业

### 1

请列举 SV39 页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？

页表项组成如下：

![../_images/sv39-pte.png](https://rcore-os.github.io/rCore-Tutorial-Book-v3/_images/sv39-pte.png)

其中 [63:54] 这 10 位是保留位， [53:10] 这 44 位是物理页号，最低的 8 位 [7:0] 则是标志位，它们的含义如下：

- 仅当 V(Valid) 位为 1 时，页表项才是合法的
- R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；
- U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问
- G 代表全局映射，即是否该页表项在所有地址空间都有效
- A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
- D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过

### 2

缺页

这次的实验没有涉及到缺页有点遗憾，主要是缺页难以测试，而且更多的是一种优化，不符合这次实验的核心理念，所以这里补两道小题。

缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断，告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。

- 请问哪些异常可能是缺页导致的？

  Instruction page fault, Load page fault, Store/AMO page fault

  

- 发生缺页时，描述相关的重要寄存器的值（lab2中描述过的可以简单点）。

  `x` 为 `s/m` 

  - `xstatus`：全局中断使能和上一个特权级信息

  - `xie`：中断使能

  - `xtvec`：陷入内核时跳转地址

  - `xscratch`：临时寄存器

  - `xepc`：缺页的指令地址

  - `xcause`：异常类型

  - `xtval`：导致缺页的虚拟地址

  - `xip`：pending 中断

    

缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做，而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。

- 这样做有哪些好处？

  数据被访问后才加载到内存可以提高内存的利用率，同时可以更快地启动程序

  

此外 COW(Copy On Write) 也是常见的容易导致缺页的 Lazy 策略，这个之后再说。其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间，然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。

- 请问处理 10G 连续的内存页面，需要操作的页表实际大致占用多少内存(给出数量级即可)？

  页数 $10G/4K=2.5*2^{10}$，叶节点 $2.5*2^{10}/2^9=5$，一级二级至少一个节点，占用 $7*4K=28K$ 内存

  

- 请简单思考如何才能在现有框架基础上实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

  建立一个新的对象记录有效但是未加载到内存中的虚拟地址，分配新虚拟地址时先不分配物理地址而是加入该对象。缺页时先查找该对象，如果地址在其中则加载至内存，建立页表项并并将其该对象中删除，不在其中再继续按现有框架处理

  

缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。

- 此时页面失效如何表现在页表项(PTE)上？

  V=0

  

### 3

双页表与单页表

为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说，用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。

- 如何更换页表？

  修改 `satp` 寄存器

- 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）

  U 位为0的地址用户态不能访问

- 单页表有何优势？（回答合理即可）

  换页表次数少，换页表的时候需要清空 TLB 和 cache，开销还是很大的

- 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

  进入用户态/内核态时都需要更换；只在任务切换时才更换，如果只是同一个任务内部用户线程和内核线程的切换，使用的页表相同，自然没必要更换页表

